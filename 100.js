/*
문제100 : 퍼즐게임

N x M으로 이루어진 아래와 같은 공간에 퍼즐이 쌓여져 있습니다.
 
퍼즐을 맞추기 위해서는 반드시 맨 오른쪽 줄로 이동시켜 줘야 합니다.
만약 종류가 같은 퍼즐이 연속될 시에 점수가 추가되며 그 퍼즐은 사라집니다.

점수는 다음과 같습니다.
- 파란색 공 : 1점
- 빨간색 공 : 2점
- 노란색 공 : 3점
- 초록색 공 : 4점
- 주황색 공 : 5점
점수는 공의 개수만큼 추가됩니다
예를 들어 빨간색 공이 2개 연속되어 없어졌을 경우 2*2 = 4점입니다.

게임 플레이어는 게임이 시작되면 어떤 퍼즐을 이동할 것인지 모두 작성합니다.
만약 비어있는 곳을 선택하게 된다면 점수가 1점 감소하며 그대로 진행합니다.
위 규칙에 맞는 점수를 리턴하는 함수를 작성하세요.


예를 들어 입력이 "1 1 1 1 3 3 3"일 경우,

총 점수는 2점으로 2를 출력해야 합니다.

```jsx
**입력**
퍼즐판 = [[0,0,0,0],[0,1,0,3],[2,5,0,1],[2,4,4,1],[5,1,1,1]]
조작 = [1,1,1,1,3,3,3]

**출력**
2
```
*/
// 답안
const 퍼즐판 = [
  [0, 0, 0, 0],
  [0, 1, 0, 3],
  [2, 5, 0, 1],
  [2, 4, 4, 1],
  [5, 1, 1, 1],
];
const 조작 = [1, 1, 1, 1, 3, 3, 3];
function solution(plate, moves) {
  let stack = [];
  let point = 0;
  while (moves.length !== 0) {
    // moves배열이 전부 소진될 동안 순회된다.
    let m = moves.shift();
    // 매 순회당 moves 배열에 앞에있는 원소를 m에 받아오고,
    for (let i = 0; i < plate.length; i++) {
      // plate를 순회 하면서,
      if (plate[i][m - 1] !== 0) {
        // 만약 plate 배열들의 m-1번째 원소가 0이 아니라면,
        if (stack[stack.length - 1] === plate[i][m - 1]) {
          // 만약 스택의 마지막 원소와 해당 원소가 같다면,
          point += plate[i][m - 1] * 2; // point에 해당원소값 곱하기 2한 값을 포인트에 누적하고,
          stack.pop(); // 해당 스택을 초기화한다.
        } else {
          // 만약 스택의 마지막 원소와 해당 원소가 같지 않다면, stack에 해당원소를 push한다.
          stack.push(plate[i][m - 1]);
        }
        plate[i][m - 1] = 0; // 위 두개 구문에 해당이 되지 않는다면,해당 원소를 0으로 만들고 break한다.
        break;
      } else if (i === plate.length - 1) {
        // 만약 위의 조건들을 모두 거치지 않고 plate의 마지막 배열에 도달하였다면, point를 1 차감한다.
        point -= 1;
      }
    }
  }

  return point;
}
console.log(solution(퍼즐판, 조작));
// console.log(solution(퍼즐판, 조작));
