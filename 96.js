/*
문제96 : 넓은 텃밭 만들기!

수연이는 밭농사를 시작하기로 마음을 먹었다. 집 앞 텃밭을 만들기로 하고 돌들을 제거하고 있는데 매우 큰 바위는 옮기지 못해 고심하고 있다.

이에 수연이는 다음과 같은 규칙을 정한다.

1. 바위를(바위는 '1'로 표기한다.) 피해 텃밭을 만들되 정사각형 모양으로 텃밭을 만든다.
2. 텃밭은 가장 넓은 텃밭 1개만 만들고 그 크기를 반환한다.
3. 만든 텃밭은 모두 '#'으로 처리한다.

<입출력 예시>

**입력**

0 0 0 0 0
0 1 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0

**출력**

3 X 3

0 0 # # #
0 1 # # #
0 1 # # #
0 0 1 0 0
0 0 0 1 0

**입력**

0 0 0 1 0
0 0 0 0 0
0 0 1 0 0
0 0 1 0 0
0 0 0 1 0

**출력**

2 X 2

# # 0 1 0
# # 0 0 0
1 0 1 0 0
0 0 1 0 0
1 0 0 1 0

***********문제***********
const 텃밭 = []; //입력받은 텃밭 리스트
let 가꾼텃밭 = []; //텃밭을 가꾼 후 저장된 리스트

// 코드를 작성해주세요

console.log(가꾼텃밭);
*/

// 답안

const 텃밭 = `0 0 0 0 0
0 1 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0`
  .replace(/1/g, "!")
  .replace(/0/g, "1")
  .replace(/!/g, "0");
// 값을 역전시켜서 계산할 수 있게 만든다.
let 역전된텃밭 = [];
for (let row of 텃밭.split(`\n`)) {
  역전된텃밭.push(row.split(" "));
}
function solution(역전된텃밭) {
  const 높이 = 역전된텃밭.length; // 2차원 배열의 길이
  const 넓이 = 역전된텃밭[0].length; // 2차원 배열안의 1차원 배열의길이
  for (let i = 0; i < 높이; i++) {
    for (let j = 0; j < 넓이; j++) {
      역전된텃밭[i][j] = parseInt(역전된텃밭[i][j], 10);
    }
    // 배열의 값들을 10진수 Int형으로 바꿈
  }
  let max = 0; // 최댓값
  let x = 0; // 최댓값의 x좌표값
  let y = 0; // 최댓값의 y좌표값
  for (let i = 1; i < 높이; i++) {
    // 1~4까지
    for (let j = 1; j < 넓이; j++) {
      // 1~4까지
      // 맨 왼쪽과 맨 윗줄을 제외하고
      if (역전된텃밭[i][j] === 1) {
        // 만약 해당값이 1이라면
        let min;
        if (역전된텃밭[i - 1][j] >= 역전된텃밭[i][j - 1]) {
          // 해당값의 윗배열 값이 해당값의 왼쪽값보다 크거나 같다면
          min = 역전된텃밭[i][j - 1]; // min 값을 해당값의 왼쪽값으로 할당한다
        } else if (역전된텃밭[i - 1][j] <= 역전된텃밭[i][j - 1]) {
          // 해당값의 윗배열 값이 해당값의 왼쪽값보다 작거나 같다면
          min = 역전된텃밭[i - 1][j]; // min 값을 해당값의 윗값으로 할당한다
        }
        if (min > 역전된텃밭[i - 1][j - 1]) {
          // 만약 min 값이 해당값의 윗,왼쪽값보다 작다면
          min = 역전된텃밭[i - 1][j - 1]; // min값을 해당값의 윗,왼쪽값으로 할당한다.
        }
        역전된텃밭[i][j] = min + 1; // 마지막으로 해당값을 min+1으로 할당한다.
        if (max < 역전된텃밭[i][j]) {
          // 만약 해당값이 max보다 크다면
          max = 역전된텃밭[i][j]; // max에 해당값을 넣고
          x = j; // max값의 x좌표를 j값으로,
          y = i; // max값의 y좌표를 i값으로 넣는다.
        }
      }
    }
  }
  // console.log(역전된텃밭);

  // console.log(x, y);
  // x= 4 , y= 2
  // max = 3
  for (let i = y - (max - 1); i < y + 1; i++) {
    // i값을 2-(3-1) = '0'부터 2 + 1 = '3' 전까지 [y 값] => 0, 1, 2
    for (let j = x - (max - 1); j < x + 1; j++) {
      // j값을 4-(3-1) = '2'부터 4 + 1 = '5' 전까지 [y 값] => 2, 3, 4
      역전된텃밭[i][j] = "#";
      // [0,2],[0,3],[0,4]
      // [1,2],[1,3],[1,4]
      // [2,2],[2,3],[2,4]
    }
  }
  for (let i = 0; i < 높이; i++) {
    for (let j = 0; j < 넓이; j++) {
      if (역전된텃밭[i][j] >= 1) {
        역전된텃밭[i][j] = 0;
      } else if (역전된텃밭[i][j] === 0) {
        역전된텃밭[i][j] = 1;
      }
    }
  }
  /* 출력 */
  console.log(`${max} x ${max}`);
  for (let i of 역전된텃밭) {
    console.log(i);
  }
  /* 출력 */
}
solution(역전된텃밭);
/*
재귀함수 : 중복의 가능성이 있으며, 탑다운 방식
Memorization : 탑다운 방식
DP(Dynamic Programming) : 중복을 하지 않습니다.
*/
